#include<stdio.h>
#include "apue.h"

//在文件开头先进行下面定义函数的声明；
void pr_stdio(const char *, FILE *);
int is_unbuffered(FILE *);
int is_linebuffered(FILE *);
int buffer_size(FILE *);

int main(void){
    FILE *fp; //创建一个指向文件的指针；属于FILE文件类型；

    fputs("enter any character\n",stdout); //将“enter...”写入指定的标准输出流stdout中；
    if(getchar()==EOF) //读取流中的一个字符；
        err_sys("getchar error");
    fputs("one line to standard error\n",stderr);//将字符写入标准错误流中；

    pr_stdio("stdin",stdin);
    pr_stdio("stdout",stdout);
    pr_stdio("stderr",stderr);

    if
}
//对每个流的一个操作，说明；fp代表了指向流的指针；
void pr_stdio(const char *name, FILE *fp){
    printf("strean= %s,",name); //将流的信息输入到标准输出流；
    if(is_unbuffered(fp))
        printf("unbuffered");
    else if(is_linebuffered(fp))
        printf("line buffered");
    else
        printf("fully buffered");
    printf(",buffer size= %d\n",buffer_size(fp));
}


//#if #endif 是C++的条件编译预处理命令；
//下面可能会有不同的实现方式，根据#if 判断是否定义相关，如定义了则会编译对应区域的代码块；

#if defined(_IO_UNBUFFERED)

int is_unbuffered(FILE *fp){
    return (fp->_flags & _IO_UNBUFFERED);
}
int is_linebuffered(FILE *fp){
    return (fp->_flags & _IO_LINE_BUF);
}
int buffer_size(FILE *fp){
    return (fp->_IO_buf_end - fp->_IO_buf_base);
}

#elif defined(__SNBF)

int is_unbuffered(FILE *fp){
    return (fp->_flags & __SNBF);
}
int is_linebuffered(FILE *fp){
    return (fp->_flags & __SLBF);
}
int buffer_size(FILE *fp){
    return (fp->buf.size);
}

#elif defined(_IONBF)

#ifdef _LP64
#define _flag __pad[4]
#define _ptr __pad[1]
#define _base __pad[2]
#endif

int is_unbuffered(FILE *fp){
    return (fp->flag & _IONBF);
}
int is_linebuffered(FILE *fp){
    return (fp->_flag & _IONBF);
}
int buffer_size(FILE *fp){
    #ifdef _LP64
        return (fp->_base-fp->_ptr);
    #else
        return (BUFSIZ);
    #endif
}
#else
#errror unkonwn stdio implementation!
#endif



#include "apue.h"

int main(void){
    char name[L_tmpnam],line[MAXLINE];
    FILE *fp;

    printf("%s\n",tmpnam(NULL));//首先使用tmpnam函数创建一个与现有文件名不同的有效路径名字字符串；

    tmpnam(name); //这里的name是指向数组的指针；
    printf("%s\n",name);

    if((fp==tmpfile())==NULL) //创建一个临时文件
        err_sys("tmpfile error");
    fputs("one line of output\n",fp);
    rewind(fp); //重定位到文件的开头位置；
    if(fgets(line,sizeof(line),fp)==NULL) //将name数组中的内容复制到line数组中；
        err_sys("fgets error");
    fputs(line,stdout); //将line中的内容输入到标准输出流中；
    exit(0);
}

#include "apue.h"
#include <errno.h>

void make_temp(char *template);

int main(){
    char good_template[]='/tmp/dirXXXXXX';
    char *bad_template="/tmp/dirXXXXXX";
    printf("trying to create first temp file...\n");
    make_temp(good_template);
    printf("trying to create second temp file...\n");
    make_temp(bad_template);
    exit(0);
}

void make_temp(char *template){
    int fd;
    struct  stst sbuf;

    if((fd=mkstemp(template))<0)
        err_sys("can't create temp file");
    printf("temp name=%s\n",template);
    close(fd);
    if(stat(template, &sbuf)<0){
        if(errno==ENOENT)
            printf("file doesn't exist\n");
        else
            err_sys("stat failed");
    }else{
        printf("file exits\n");
        unlink(template);
    }
}


//5-15
#include "apue.h"
#define BSZ 48

int main(){
    FILE *fp;
    char buf[BSZ];

    memset(buf,'a',BSZ-2); //用字符a来初始化buf所指向的缓冲区；
    buf[BSZ-2]='\0';
    buf[BSZ-1]='x';
    if((fp=fmemopen(buf,BSZ,"w+")==NULL))
        err_sys("fmemopen failed!");
    printf("initial buffer contents: %s\n",buf);
    fprintf(fp,"hello world"); //将字符串写入到指定的流fp中；
    printf("before flush :%s\n",buf);
    fflush(fp); //冲刷流；
    printf("after fflush :%s\n",buf); //打印查看冲刷之后流中的内容是什么；
    printf("len of string in buf=%ld\n",(long)strlen(buf));

    memset(buf,'b',BSZ-2);
    buf[BSZ-2]='\0';
    buf[BSZ-1]='x';
    fprintf(fp,"hello world");
    fseek(fp,0,SEEK_SET);
    printf("after fseek: %s\n",buf);
    printf("len of string in buf=%ld\n",(long)strlen(buf));

    memset(buf,'c',BSZ-2);
    buf[BSZ-2]='\0';
    buf[BSZ-1]='x';
    fprintf(fp);
    fseek(fp,0,SEEK_SET);
    printf("after fseek: %s\n",buf);
    printf("len of string in buf=%ld\n",(long)strlen(buf));

    return 0;
}



//程序6-2
#include<pwd.h>
#include<stddef.h>
#include<string.h>

//这个函数返回一个指向口令文件结构体的指针；
struct passwd * getpwnam(const char *name){
    struct passwd *ptr;

    setpwent();
    //这里再函数开始的时候调用setpwent函数是自我保护的措施，以便确保调用者在使用之前已经调用getpwent打开了
    //有关文件情况下，反绕有关文件使得他们定位到文件开始处。
    while((ptr=getpwent())!=NULL)
        if(strcmp(name,ptr->pw_name)==0)
            break;
    endpwent();
    return(ptr);
}
//注意：getpwnam和getpwuid完成后不应该使有关文件处于打开状态，所以应该使用endpwent关闭他们。




#include "apue.h"
static void my_exit1(void);
static void my_exit2(void);

int main(void){
    if(atexit(my_exit2)!=0)err_sys("can't register my_exit2");
    if(atexit(my_exit1)!=0)err_sys("can't register my_exit1");
    if(atexit(my_exit1)!=0)err_sys("can't register my_exit1");
    printf("main is done\n");
    return(0);
}

static void my_exit1(void){
    printf("first exit handler\n");
}
static void my_exit2(void){
    printf("second exit handler\n");
}


//7-4

#include"apue.h"
int main(int argc,char *argv[]){
    int i;
    for(i=0;i<argc;i++){
        printf("arve[%d]:%s\n",i,argv[i]);
    }
    exit(0);
}


//7-9

//下面程序：
//主循环从标准输入读一行，然后调用do_line处理该输入行。do_line函数调用get_token从该输入行中
//取下一个标记，一行中的第一个标记假定是一条某种形式的命令，switch语句实现命令的选择。
#include"apue.h"
#define TOK_ADD 5 //将5使用TOK_ADD表示；

//首先对将要使用到的函数进行函数声明；
void do_line(char *);  //用于处理每一个输入行；
void cmd_add(void);  //
int get_token(void); //获取每一个输入行的标记；

int main(void){
    char line[MAXLINE]; //用于存入每次读入的命令，按照字符串的形式存入该字符数组中；
    //fgets函数从标准输入流中读取MAXLINE歌字符存储到字符指针标量line所指向的内存空间；
    //它返回值是一个指针，指向字符串中第一个字符的地址。读取输入的每一行；
    while(fgets(line,MAXLINE,stdin)!=NULL) 
        do_line(line); //对输入流中获取的命令进行处理；
    exit(0);
}
char *top_ptr;

//对每一行进行处理；参数为获取的每一行命令所存储的字符数组的首地址指针；
void do_line(char *ptr){
    int cmd;

    tok_ptr=ptr;
    //获取每一个标记进行检查与处理；
    while((cmd=get_token())>0){
        switch(cmd){
            case TOK_ADD:
                cmd_add();
                break;
        }
    }
}
void cmd_add(void){
    int token;
    token=get_token();
}

int get_token(void){

}

//====================================

#include"apue.h"
#include<setjmp.h>

#define TOK_ADD 5

jmp_buf jmpbuffer;

int main(void){
    char line[MAXLINE];
    if(setjmp(jmpbuffer)!=0)printf("error");
    while(fgets(line,MAXLINE,stdin)!=NULL)do_line(line);
    exit(0);
}

char *top_ptr;

void do_line(char *ptr){
    int cmd;

    tok_ptr=ptr;
    while((cmd=get_token())>0){
        switch(cmd){
            case TOK_ADD:
                cmd_add();
                break;
        }
    }
}
void cmd_add(void){
    int token;
    token=get_token();
    if(token<0){
        longjmp(jmpbuffer,1);
    }
}

int get_token(void){

}


//=================================================
#include"apue.h"
#include<setjmp.h>

//首先声明两个静态函数；
static void f1(int,int,int,int);
static void f2(void);

//声明静态变量；
static jmp_buf jmpbuffer;
static int globval; //全局变量；

int main(void){
    int autoval; //自动变量；
    register int regival; //寄存器变量；
    volatile int volaval; //易变变量；
    static int statval; //静态变量；

    globval=1; //全局变量；
    autoval=2;
    regival=3;
    volaval=4;
    statval=5;

    if(setjmp(jmpbuffer)!=0){
        printf("after longjmp:\n");
        printf("globval=%d,autoval=%d,regival=%d,volaval=%d,statval=%d\n",globval,autoval,regival,volaval,statval);
        exit(0);
    }
    globval=95;autoval=96;regival=97;volaval=98;
    statval=99;

    f1(autoval,regival,volaval,statval);
    exit(0);
}

static void f1(int i,int j,int k,int l){
    printf("in f1():\n");
    printf("globval=%d,autoval=%d,regival=%d,volaval=%d,statval=%d\n",globval,i,j,k,l);
    f2();
}

static void f2(void){
    longjmp(jmpbuffer,1);//调用longjmp；
}


//7-14
#include<stdlib.h>

FILE * open_data(void){
    FILE *fp;
    char databuf[BUFSIZ];

    if((fp=fopen()))
}


//7-16
#include"apue.h"
#include<sys/resource.h>

#define doit(name) pr_limits(#name,name)
static void pr_limits(const char*,int);

int main(void){
#ifdef RLIMIT_AS
    doit(RLIMIT_AS);
#endif
    doit(RLIMIT_CORE);
    doit(RLIMIT_CPU);
    doit(RLIMIT_DATA);
    doit(RLIMIT_FSIZE);
#ifdef RLIMIT_MEMLOCK
    doit(RLIMIT_MEMLOCK);
#endif

#ifdef RLIMIT_MSGQUEUE
    doit(RLIMIT_MSGQUEUE);
#endif

#ifdef RLIMIT_NICE
    doit(RLIMIT_NICE);
#endif

    doit(RLIMIT_NOFILE);

#ifdef RLIMIT_NPROC
    doit(RLIMIT_NPROC);
#endif

#ifdef RLIMIT_NPTS
    doit(RLIMIT_NPTS);
#endif

#ifdef RLIMIT_RSS
    doit(RLIMIT_RSS);
#endif

#ifdef RLIMIT_SBSIZE
    doit(RLIMIT_SBSIZE);
#endif

#ifdef RLIMIT_SIGPENDING
    doit(RLIMIT_SIGPENDING);
#endif

    doit(RLIMIT_STACK);

#ifdef RLIMIT_SWAP
    doit(RLIMIT_SWAP);
#endif

#ifdef RLIMIT_VMEM
    doit(RLIMIT_VMEM);
#endif

    exit(0);
}

static void pr_limits(const char *name,int resource){
    struct rlimit limit;
    unsigned long long lim;

    if(getrlimit(resource,&limit)<0) err_sys("getrlimit error for %s",name);
    printf("%-14s ",name);
    if(limit.rlim_cur==RLIM_INFINITY){
        printf("(infinite) ");
    }else{
        lim=limit.rlim_cur;
        printf("%10lld ",lim);
    }
    if(limit.rlim_max==RLIM_INFINITY){
        printf("(infinite)");
    }else{
        lim=limit.rlim_max;
        printf("%10lld",lim);
    }
    putchar((int)'\n');
}



#include"apue.h"

//全局变量
int globval=6;
char buf[]="a write to stdout\n";

int main(){
    int var;
    pid_t pid;

    var=88;
    //write(STDOUT_FILENO,buf,sizeof(buf)-1)把缓冲区buf中的内容都拷贝到输出流中；
    if(write(STDOUT_FILENO,buf,sizeof(buf)-1)!=sizeof(buf)-1)
        err_sys("write error!");
    printf("before fork\n");

    if((pid=fork())<0){
        err_sys("fork error");
    }else if(pid==0){  //pid=0表示是子进程；
        globval++;
        var++;
    }else{ //非0正数是父进程；
        sleep(2);
    }

    printf("pid=%ld,glob=%d,var=%d\n",(long)getpid(),globval,var);
    exit(0);
}


//8-3程序，将fork函数替换成了vfork函数：
//删除了对标准输出write的调用，不再需要让父进程调用sleep，因为可以保证，
//在子进程调用exec或exit之前，内核会使得父进程进入休眠状态；
#include"apue.h"
int globval=6;
int main(void){
    int var;
    pid_t pid;

    var=88;
    printf("before vfork\n");
    if((pid=vfork())<0){
        err_sys("vfork error");
    }else if(pid==0){
        globval++;
        var++;
        _exit(0);
    }
    printf("pid=%ld,glob=%d,var=%d\n",(long)getpid(),globval,var);
    exit(0);
}


//8-5 使用宏打印进程终止状态的说明；
#include"apue.h"
#include<sys/wait.h>

void pr_exit(int status)
{
    if(WIFEXITED(status)) //如为正常终止子进程返回状态则为真。
        printf("normal termination, exit status =%d\n",WEXITSTATUS(status));
    else if(WIFSIGNALED(status)) //若为异常终止子进程返回的状态则为真。
        printf("abnormal termination, signal number =%d%s\n",WTERMSIG(status),
#ifdef WCOREDUMP 
        WCOREDUMP(status)?"(core file generated)":"");
#else
        "");
#endif
    else if(WIFSTOPPED(status)) //如为当前子进程的返回状态则为真。
        printf("child stopped, signal number=%d\n",WSTOPSIG(status));
}

int main(void)
{
    pid_t pid;
    int status;
    //使用exit正常退出状态：
    if((pid=fork())<0) err_sys("fork error"); //创建子进程失败；
    else if(pid==0)exit(7); //该子进程退出是状态为7；如果是创建的；

    if(wait(&status)!=pid)err_sys("wait error");  //这里将终止进程的终止状态存放在status所指向的存储单元；
    pr_exit(status);//对状态进行检查类型；

    //使用abort函数终止状态：立即终止当前进程，产生异常程序终止，进程终止时不会销毁任何对象；
    if((pid=fork())<0)err_sys("fork error");
    else if(pid==0)abort(); 

    if(wait(&status)!=pid)err_sys("wait error");
    pr_exit(status);

    //异常终止；除0出错：
    if((pid=fork())<0)err_sys("fork error");
    else if (pid==0) status/=0;

    if (wait(&status)!=pid)err_sys("wait error");
    pr_exit(status);

    exit(0);
}



//8-8
#include"apue.h"
#include<sys/wait.h>

int main(void){
    pid_t pid; //用于获取进程号；

    if((pid=fork())<0)err_sys("fork error");
    else if(pid==0){ //在第一个子进程内；
        if((pid=fork())<0)err_sys("fork error");
        else if(pid>0)exit(0); //大于0表示是该第一层的子进程，退出；这样就第二层的子进程没有了父进程；
        sleep(2);
        printf("second child parent pid=%ld\n",(long)getppid()); //所以这里的没有父进程的子进程被init进程收养；
        exit(0);
    }
    if(waitpid(pid,NULL,0)!=pid)err_sys("waitpid error");
    exit(0);
}

#include"apue.h"
TELL_WAIT();
if((pid=fork())<0){
    err_sys("fork error");
}else if(pid==0){
    TELL_PARENT(getppid()); //告诉父进程已经创建好了子进程；
    WAIT_PARENT(); //等待父进程；
    exit(0);
}
TELL_CHILD(pid);
WAIT_CHILD();
exit(0);

//8-12
#include "apue.h"
static void charatatime(char *);

int main(void){
    pid_t pid;
    if((pid=fork())<0){
        err_sys("fork error");
    }else if(pid==0){
        charatatime("output from child\n");
    }else{
        charatatime("output from parent\n");
    }
    exit(0);
}
static void charatatime(char *str){
    char *ptr;
    int c;
    setbuf(stdout,NULL);
    for(ptr=str;(c=*ptr++)!=0;){
        putc(c,stdout);
    }
}

//8-13
#include "apue.h"
static void charatatime(char *);

int main(void){
    pid_t pid;
    TELL_WAIT();

    if((pid=fork())<0){
        err_sys("fork error");
    }else if(pid==0){
        WAIT_PARENT(); //等待父进程；
        charatatime("output from child\n");
    }else{
        charatatime("output from parent\n");
        WAIT_CHILD(pid); //告诉子进程自己已经结束了；
    }
    exit(0);
}
static void charatatime(char *str){
    char *ptr;
    int c;
    setbuf(stdout,NULL);
    for(ptr=str;(c=*ptr++)!=0;){
        putc(c,stdout);
    }
}

//8-16
#include"apue.h"
#include<sys/wait.h>

char *env_init[]={"USER=unknown","PATH=/temp",NULL};//创建一个字符数组，
/*上面这段代码是一个字符指针数组，该数组被设计为一个环境变量数组，用于传递main函数中的参数；
这个数组中的每个元素都是一个指向以null结尾的字符串的的指针；
*/
int main(void){
    pid_t pid; //用于记录进程ID；
    if((pid=fork())<0){
        err_sys("fork error");
    }else if(pid==0){ //对子进程的操作：
        //execle函数第一个参数为要执行可执行文件的pathname，后面都是字符指针；函数出错返回-1；
        if(execle("/home/sar/bin/echoall","echoall","myarg1","MY ARG2",(char*)0,env_init)<0)
            err_sys("execle error");
    }
    //等待特定子进程，即等待pid进程，NULL表示不获取子进程的返回状态，0表示等待任何子进程退出；
    if(waitpid(pid,NULL,0)<0)
        err_sys("wait error");
    if((pid=fork())<0){
        err_sys("fork error");
    }else if(pid==0){
        //execlp直接第一个为filename，后面为指向字符串的字符指针；
        if(execlp("echoall","echoall","only 1 arg",(char *)0)<0)
            err_sys("execlp error");
    }
    exit(0);
}

//8-17
#include"apue.h"
int main(int argc, char *argv[]){
    int i;
    char **ptr;
    extern char **environ;
    for(i=0;i<argc;i++){
        printf("argv[%d]:%s\n",i,argv[i]);
    }
    for(ptr=environ;*ptr!=0;ptr++){
        printf("%s\n",*ptr);
    }
    exit(0);
}

//8-20
#include"apue.h"
#include<sys/wait.h>

int main(void){
    pid_t pid;

    if((pid=fork())<0){
        printf("fork error");
    }else if(pid==0){
        if(execl("/home/kyle/Files/chapter8/testinterp","testinterp","myarg1","MY ARG2",(char *)0)<0)
            err_sys("execl error");
    }
    if(waitpid(pid,NULL,0)<0){
        err_sys("waitpid error");
    }
    exit(0);
}

//7-4 将所有命令行参数都回显到标准输出上。
#include"apue.h"
int main(int argc, char *argv[]){
    int i;

    for(i=0;i<argc;i++){
        printf("argv[%d]:%s\n",i,argv[i]);
    }
    exit(0);
}



//8-22
#include<sys/wait.h>
#include<errno.h>
#include<unistd.h>

int system(const char *cmdstring){
    pid_t pid;
    int status;

    if(cmdstring==NULL)
        return(1);

    if((pid=fork())<0){
        status=-1;
    }else if(pid==0){
        execl("/bin/sh","sh","-c",cmdstring,(char *)0);
        _exit(127);
    }else{
        while(waitpid(pid,&status,0)<0){
            if(errno!=EINTR){
                status=-1;
                break;
            }
        }
    }
    return(status);
}

#include<sys/wait.h>
#include<errno.h>
#include<unistd.h>

int system(const char *cmdstring){
    pid_t pid;
    int status;

    if(cmdstring==NULL)
        return(1);

    if((pid=fork())<0){
        status=-1;
    }else if(pid==0){
        execl("/bin/sh","sh","-c",cmdstring,(char *)0);
        _exit(127);
    }else{
        while(waitpid(pid,&status,0)<0){
            if(errno!=EINTR){
                status=-1;
                break;
            }
        }
    }
    return(status);
}


//8-23
#include"apue.h"
#include<sys/wait.h>

void pr_exit(int status)
{
    if(WIFEXITED(status)) 
        printf("normal termination, exit status =%d\n",WEXITSTATUS(status));
    else if(WIFSIGNALED(status))
        printf("abnormal termination, signal number =%d%s\n",WTERMSIG(status),
#ifdef WCOREDUMP 
        WCOREDUMP(status)?"(core file generated)":"");
#else
        "");
#endif
    else if(WIFSTOPPED(status))
        printf("child stopped, signal number=%d\n",WSTOPSIG(status));
}

int main(void){
    int status;

    if((status=system("date"))<0)
        err_sys("system() error");

    pr_exit(status);

    if((status=system("nosuchcommand"))<0)
        err_sys("system() error");

    pr_exit(status);

    if((status=system("who; exit 44"))<0)
        err_sys("system() error");
    
    pr_exit(status);
    exit(0);

}




//8-24
#include"apue.h"
void pr_exit(int status)
{
    if(WIFEXITED(status)) 
        printf("normal termination, exit status =%d\n",WEXITSTATUS(status));
    else if(WIFSIGNALED(status))
        printf("abnormal termination, signal number =%d%s\n",WTERMSIG(status),
#ifdef WCOREDUMP 
        WCOREDUMP(status)?"(core file generated)":"");
#else
        "");
#endif
    else if(WIFSTOPPED(status))
        printf("child stopped, signal number=%d\n",WSTOPSIG(status));
}
int main(int argc, char *argv[]){
    int status;

    if(argc<2)
        err_quit("command-line argument required");

    if((status=system(argv[1])<0)
        err_sys("system() error"));
    
    pr_exit(status);

    exit(0);
}

//8-25
#include"apue.h"

int main(void){
    printf("real uid=%d,effective uid=%d\n",getuid(),geteuid());
    exit(0);
}


//8-30
#include"apue.h"
#include<errno.h>
#include<sys/time.h>

#if defined(MACOS)
#include<sys/syslimits.h>
#elif defined(SOLARIS)
#include<limits.h>
#elif defined(BSD)
#include<sys/param.h>
#endif

unsigned long long count;
struct timeval end;
void checktime(char *str){
    struct timeval tv;

    gettimeofday(&tv,NULL);
    if(tv.tv_sec>=end.tv_sec && tv.tv_usec>=end.tv_usec){
        printf("%s count=%11d\n",str,count);
        exit(0);
    }
}

int main(int argc,char *argv[]){
    pid_t pid;
    char *s;
    int nzero,ret;
    int adj=0;

    setbuf(stdout,NULL);
#if defined(NZERO)
    nzero=NZERO;
#elif defined(_SC_NZERO)
    nzero=sysconf(_SC_NZERO);
#else
#error NZERO undefined
#endif
    printf("NZERO=%d\n",nzero);
    if(argc==2)adj=strtol(argv[1],NULL,10);
    gettimeofday(&end,NULL);
    end.tv_sec+=10;

    if((pid=fork())<0){
        err_sys("fork failed");
    }else if(pid==0){
        s="child";
        printf("current nice value in child is %d,adjusting by %d\n",nice(0)+nzero,adj);
        errno=0;
        if((ret=nice(adj))==-1 && errno!=0)err_sys("child set scheduling priority");
        printf("now child nice value is %d\n",ret+nzero);
    }else{
        s="parent";
        printf("current nice value in parent is %d\n",nice(0)+nzero);
    }
    for(;;){
        if(++count==0){
            err_quit("%s counter wrap",s);
        }
        checktime(s);
    }
}

//8-31
#include"apue.h"
#include<sys/times.h>

static void pr_times(clock_t,struct tms *,struct tms *);
static void do_cmd(char *);

int main(int argc,int argv[]){
    int i;
    setbuf(stdout,NULL);
    for(i=1;i<argc;i++){
        do_cmd(argv[i]);
    }
    exit(0);
}

static void do_cmd(char *cmd){
    struct tms tmsstart,tmsend;
    clock_t start,end;
    int status;

    printf("\ncommand:%s\n",cmd);

    if((start=times(&tmsstart))==-1)err_sys("times error");
    if((status=system(cmd))<0)err_sys("times error");
    if((end=times(&tmsend))==-1)err_sys("times error");

    pr_times(end-start,&tmsstart,&tmsend);
    pr_exit(status);
}

static void pr_times(clock_t real,struct tms *tmsstart,struct tms *tmsend){
    static long clktck=0;
    if(clktck==0){
        if((clktck=sysconf(_SC_CLK_TCK))<0)err_sys("sysconf error");
    }

    printf()
}



// orphan.c
#include <unistd.h>
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <errno.h>

void handler(int sig) {
  printf("hello sighup, pid = %d\n", getpid());
}

void print(char *name) {
  printf("%s: pid = %d, ppid = %d, pgrp = %d, tpgrp = %d\n", 
      name, getpid(), getppid(), getpgid(getpid()), tcgetpgrp(0));
  fflush(stdout);
}

int main() {
  char c;
  pid_t pid;
  print("parent"); //父进程打印信息；

  pid = fork();  //首先创建一个子进程；
  if (pid < 0) {
    perror("fork");
  }   
  else if (pid > 0) { //让父进程等待一会；
    sleep(5);
  }
  else {
    print("child");
    signal(SIGHUP, handler); //该函数表示设置某一信号对应执行的动作；
    kill(getpid(), SIGTSTP); //获取当前进程ID（子进程ID），kill函数用于向进程组或进程发送信号；
    //这里就是向子进程发送SIGTSTP信号（该信号表示停止进程的运行）；
    signal(SIGCONT,handler);  //看看是不是会收到新的继续运行的信号；
    print("child");  //为什么这里可以执行？

    if (read(STDIN_FILENO, &c, 1) != 1) {
      printf("read error, error number: %d\n", errno);
    }   
    exit(0);
  }
  return 0;
}

//10-2
#include"apue.h"

static void sig_usr(int);

int main(void){
    if(signal(SIGUSR1,sig_usr)==SIG_ERR)
        err_sys("can't catch SIGUSR1");
    if(signal(SIGUSR2,sig_usr)==SIG_ERR)
        err_sys("can't catch SIGUSR2");
    for(;;)
        pause();
}

static void sig_usr(int signo){
    if(signo==SIGUSR1)
        printf("receives SIGUSR1\n");
    else if(signo==SIGUSR2)
        printf("received SIGUSR2\n");
    else
        err_dump("received signal %d\n",signo);
}


//10-7
#include<signal.h>
#include<unistd.h>

static void sig_alrm(int signo){
    /*nothing to do, just return to wake up the pause*/
}

unsigned int sleep1(unsigned int seconds){
    if(signal(SIGALRM,sig_alrm)==SIG_ERR)
        alarm(seconds);
    alarm(seconds);
    pause();
    return (alarm(0));
}

//10-8
#include<setjmp.h>
#include<signal.h>
#include<unistd.h>

static jmp_buf env_alrm;

static void sig_alrm(int signo){
    longjmp(env_alrm,1);
}

unsigned int sleep2(unsigned int seconds){
    if(signal(SIGALRM,sig_alrm)==SIG_ERR)
        return(seconds);
    if (setjmp(env_alrm)==0){
        alarm(seconds);
        pause();
    }
    return(alarm(0));
}


//10-9
#include "apue.h"

unsigned int sleep2(unsigned int);
static void sig_int(int);

int main(void){
    unsigned int unslept;
    if(signal(SIGINT,sig_int)==SIG_ERR)
        err_sys("signal(SIGINT) error");
    unslept=sleep2(5);
    printf("sleep2 returned : %u\n",unslept);
    exit(0);
}

//10-9
#include "apue.h"
unsigned int sleep2(unsigned int);
static void sig_int(int);

static jmp_buf env_alrm;

static void sig_alrm(int signo){
    longjmp(env_alrm,1);
}

unsigned int sleep2(unsigned int seconds){
    if(signal(SIGALRM,sig_alrm)==SIG_ERR)
        return(seconds);
    if (setjmp(env_alrm)==0){
        alarm(seconds);
        pause();
    }
    return(alarm(0));
}

int main(void){
    unsigned int unslept;
    if(signal(SIGINT,sig_int)==SIG_ERR)
        err_sys("signal(SIGINT) error");
    unslept=sleep2(5);
    printf("sleep2 returned: %u\n",unslept);
    exit(0);
}

static void sig_int(int signo){
    int i,j;
    volatile k;

    printf("\nsig_int starting\n");
    for(i=0;i<300000;i++)
        for(j=0;j<4000;j++)
            k+=i*j;
    printf("sig_int finished\n");
}


//10-10
#include "apue.h"

static void sig_alrm(int);

int main(void){
    int n;
    char line[MAXLINE];

    if(signal(SIGALRM,sig_alrm)==SIG_ERR)
        err_sys("signal(SIGALRM) error");
    
    alarm(10);
    if((n=read(STDIN_FILENO,line,MAXLINE))<0)
        err_sys("read error");
    alarm(0);

    write(STDOUT_FILENO,line,n);
    exit(0);
}

static void sig_alrm(int signo){
    
}

//10-11
#include"apue.h"
#include<setjmp.h>

static void sig_alrm(int);
static jmp_buf env_alrm;

int main(void){
    int n;
    char line[MAXLINE];

    if(signal(SIGALRM,sig_alrm)==SIG_ERR)
        err_sys("signal(SIGALRM) error");
    if(setjmp(env_alrm)!=0)
        err_quit("read timeout");
    alarm(10);
    if((n=read(STDIN_FILENO,line,MAXLINE))<0)
        err_sys("read error");
    alarm(0);

    write(STDOUT_FILENO,line,n);
    exit(0);
}

static void sig_alrm(int signo){
    longjmp(env_alrm,1);
}





//10-12 对于一些信号集处理函数的实现：
#include<signal.h>
#include<errno.h>

//在signal.h中往往将NSIG定义为一个信号的数字；
#define SIGBAD(signo)((signo<=0 || signo >= NSIG)) //将函数定义为参数为signo，判断其值是否越界；
int sigaddset(sigset_t *set,int signo){
    if(SIGBAD(signo)){
        errno=EINVAL; //EINVAL表示是一个无效的参数；
        return(-1);
    }
    *set |=1<<(signo-1);
    return(0);
}

int sigdelset(sigset_t *set,int signo){
    if(SIGBAD(signo)){
        errno=EINVAL;
        return(-1);
    }
    *set &=~(1<<(signo-1));
    return(0);
}

int sigismember(const sigset *set,int signo){
    if(SIGBAD(signo)){
        errno=EINVAL;
        return(-1);
    }
    return (*set & (1<<(signo-1))!=0);
}



//10-15
#include "apue.h"
static void sig_quit(int);

int main(void){
    sigset_t newmask,oldmask,pendmask;

    if(signal(SIGQUIT,sig_quit)==SIG_ERR)
        err_sys("can't catch SIGQUIT");
    sigemptyset(&newmask);
    sigaddset(&newmask,SIGQUIT);
    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0)
        err_sys("SIG_BLOCK error");

    sleep(5);

    if(sigpending(&pendmask)<0)
        err_sys("sigpending error");
    if(sigismember(&pendmask,SIGQUIT))
        printf("\nSIGQUIT pending\n");

    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)
        err_sys("SIG_SETMASK error");
    printf("SIGQUIT unblocked\n");

    sleep(5);
    exit(0);
}

static void sig_quit(int signo){
    printf("caught SIGQUIT\n");
    if(signal(SIGQUIT,SIG_DFL)==SIG_ERR)
        err_sys("can't reset SIGQUIT");
}

//---------------
#include "apue.h"
static void sig_quit(int);

int main(void){
    sigset_t newmask,oldmask,pendmask;  //定义几个信号；

    if(signal(SIGQUIT,sig_quit)==SIG_ERR) //用于捕捉SIGQUIT信号；
        err_sys("can't catch SIGQUIT");
    sigemptyset(&newmask); //将newmask设置为0；
    sigaddset(&newmask,SIGQUIT); //将SIGQUIT添加到信号集newmask中；
    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0)  //使用sigprocmask函数将newmask和oldmask信号集合并；
        err_sys("SIG_BLOCK error");
    //合并完信号集就是将SIGQUIT信号屏蔽字设置开启，这样就是将SIGQUIT信号屏蔽；在此期间该信号不会被阻塞；
    sleep(5);

    //在休眠了5秒之后，检查该信号是否是未决的，然后将SIGQUIT设置为不再阻塞；
    if(sigpending(&pendmask)<0) //通过调用sigpending函数返回该进程当前未决的信号集；
        err_sys("sigpending error");
    if(sigismember(&pendmask,SIGQUIT)) //判断SIGQUIT是否在当前未决的信号集内；
        printf("\nSIGQUIT pending\n");

    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)//将该进程的信号屏蔽字重新设置为oldmask指向的信号；（恢复）
        err_sys("SIG_SETMASK error");
    printf("SIGQUIT unblocked\n");

    sleep(5);
    exit(0);
}

static void sig_quit(int signo){
    printf("caught SIGQUIT\n");
    if(signal(SIGQUIT,SIG_DFL)==SIG_ERR)
        err_sys("can't reset SIGQUIT");
}


//10-20
#include"apue.h"
#include<setjmp.h>
#include<time.h>
#include<errno.h>

static void sig_usr1(int);
static void sig_alrm(int);
static sigjmp_buf jmpbuf;
static volatile sig_atomic_t canjump;

void pr_mask(const char *str){
    sigset_t sigset;
    int errno_save;

    errno_save=errno;
    if(sigprocmask(0,NULL,&sigset)<0){ 
        err_sys("sigprocmask error");
    }else{
        printf("%s",str);
        if(sigismember(&sigset,SIGINT))
            printf(" SIGINT");
        if(sigismember(&sigset,SIGQUIT))
            printf(" SIGQUIT");
        if(sigismember(&sigset,SIGUSR1))
            printf(" SIGUSR1");
        if(sigismember(&sigset,SIGALRM))
            printf(" SIGALRM");

        printf("\n");
    }
    errno=errno_save;
}

int main(void){
    if(signal(SIGUSR1,sig_usr1)==SIG_ERR)
        err_sys("signal(SIGUSR1) error");
    if(signal(SIGALRM,sig_alrm)==SIG_ERR)
        err_sys("signal(SIGALRM) error");
    
    pr_mask("starting main: ");
    if(sigsetjmp(jmpbuf,1)){
        pr_mask("ending main: ");
        exit(0);
    }
    canjump=1;
    for( ; ;)
        pause();
}

static void sig_usr1(int signo){
    time_t starttime;
    if(canjump==0)
        return;
    pr_mask("starting sig_usr1: ");

    alarm(3);
    starttime=time(NULL);
    for(;;)
        if(time(NULL)>starttime+5)
            break;
    pr_mask("finishing sig_usr1: ");

    canjump=0;
    siglongjmp(jmpbuf,1);
}

static void sig_alrm(int signo){
    pr_mask("in sig_alrm: ");
}

//----------------------------
#include"apue.h"
#include<setjmp.h>
#include<time.h>
#include<errno.h>

static void sig_usr1(int);
static void sig_alrm(int);
static sigjmp_buf jmpbuf;
static volatile sig_atomic_t canjump;

void pr_mask(const char *str){
    sigset_t sigset;
    int errno_save;

    errno_save=errno;
    if(sigprocmask(0,NULL,&sigset)<0){  //这里获取该进程的当前的信号屏蔽字；存储在sigset中；
        err_sys("sigprocmask error");
    }else{
        printf("%s",str); //答应输入的字符串；
        //下面的几个if判断语句主要是判断几个信号是否在当前的信号屏蔽字中；
        if(sigismember(&sigset,SIGINT)) 
            printf(" SIGINT");
        if(sigismember(&sigset,SIGQUIT))
            printf(" SIGQUIT");
        if(sigismember(&sigset,SIGUSR1))
            printf(" SIGUSR1");
        if(sigismember(&sigset,SIGALRM))
            printf(" SIGALRM");

        printf("\n");
    }
    errno=errno_save;
}


int main(void){
    if(signal(SIGUSR1,sig_usr1)==SIG_ERR) //用于捕捉SIGUSR1信号；
        err_sys("signal(SIGUSR1) error"); 
    if(signal(SIGALRM,sig_alrm)==SIG_ERR) //用于捕捉闹钟的信号；
        err_sys("signal(SIGALRM) error");
    
    pr_mask("starting main: "); //当前主要是打印starting字符串，同时获取当前信号屏蔽字；
    //sigsetjmp的第二个参数为1非0，那么就可以在调用时，在env中保存进程的当前信号屏蔽字；
    if(sigsetjmp(jmpbuf,1)){ //sigsetjmp在第一次调用的时候返回0，从longjmp返回的时候就是非0
        pr_mask("ending main: "); //进入这个if语句内，表示已经从longjmp函数返回来了；
        exit(0);
    }
    canjump=1;
    for( ; ;)
        pause();  //该for循环主要是使得程序等待信号的接收；
}

//用于处理SIGUSR1的函数；
static void sig_usr1(int signo){
    time_t starttime;   //用于记录起始的时间；
    if(canjump==0)
        return;
    pr_mask("starting sig_usr1: "); //获取在该信号处理程序运行开始时的进程的信号屏蔽字的情况；

    alarm(3); //设置闹钟定时；
    starttime=time(NULL);
    //下面的for循环使得该程序停留5s后中断，表示该函数完成；也就是alarm闹钟的信号在该函数处理程序结束之前触发；
    for(;;)
        if(time(NULL)>starttime+5)
            break;
    pr_mask("finishing sig_usr1: ");

    canjump=0; //将canjump设置为0；
    siglongjmp(jmpbuf,1); //将跳转会调用该信号处理函数的位置；
}

static void sig_alrm(int signo){
    pr_mask("in sig_alrm: ");
}

//10-22
#include "apue.h"

static void sig_int(int);

void pr_mask(const char *str){
    sigset_t sigset;
    int errno_save;

    errno_save=errno;
    if(sigprocmask(0,NULL,&sigset)<0){ 
        err_sys("sigprocmask error");
    }else{
        printf("%s",str);
        if(sigismember(&sigset,SIGINT))
            printf(" SIGINT");
        if(sigismember(&sigset,SIGQUIT))
            printf(" SIGQUIT");
        if(sigismember(&sigset,SIGUSR1))
            printf(" SIGUSR1");
        if(sigismember(&sigset,SIGALRM))
            printf(" SIGALRM");

        printf("\n");
    }
    errno=errno_save;
}

int main(void){
    sigset_t newmask,oldmask,waitmask;
    pr_mask("program start:");
    if(signal(SIGINT,sig_int)==SIG_ERR)
        err_sys("signal(SIGINT) error");
    sigemptyset(&waitmask);
    sigaddset(&waitmask,SIGUSR1);
    sigemptyset(&newmask);
    sigaddset(&newmask,SIGINT);

    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0)
        err_sys("SIG_BLOCK error");
    pr_mask("in critical region:");
    if(sigsuspend(&waitmask)!=-1)
        err_sys("sigsuspend error");
    
    pr_mask("after return from sigsuspend:");

    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)
        err_sys("SIG_SETMASK error");
    
    pr_mask("program exit:");
    exit(0);
}
static void sig_int(int signo){
    pr_mask("\nin sig_int");
}

//------------------------------------------
#include "apue.h"

static void sig_int(int);

void pr_mask(const char *str){
    sigset_t sigset;
    int errno_save;

    errno_save=errno;
    if(sigprocmask(0,NULL,&sigset)<0){  //获取当前进程的信号屏蔽字；
        err_sys("sigprocmask error");
    }else{ //判断信号是否在当前的信号屏蔽字中；
        printf("%s",str);
        if(sigismember(&sigset,SIGINT))
            printf(" SIGINT");
        if(sigismember(&sigset,SIGQUIT))
            printf(" SIGQUIT");
        if(sigismember(&sigset,SIGUSR1))
            printf(" SIGUSR1");
        if(sigismember(&sigset,SIGALRM))
            printf(" SIGALRM");

        printf("\n");
    }
    errno=errno_save;
}

int main(void){
    sigset_t newmask,oldmask,waitmask; //信号集对应的表示，位表示方法等；
    pr_mask("program start:");
    if(signal(SIGINT,sig_int)==SIG_ERR) //这里捕捉sig_int信号；并且进行对应的信号处理程序；
        err_sys("signal(SIGINT) error");
    sigemptyset(&waitmask); //将该信号屏蔽字设置位全0，不阻塞任何信号；
    sigaddset(&waitmask,SIGUSR1); //将SIGUSR1信号添加到对应的阻塞中；
    sigemptyset(&newmask); //清空；
    sigaddset(&newmask,SIGINT); //添加阻塞信号SIGINT；

    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0) //将newmask中的信号屏蔽添加到oldmask中的信号屏蔽字中；
        err_sys("SIG_BLOCK error");
    pr_mask("in critical region:"); //此时已经在原有基础上添加了SIGINT信号的阻塞；
    if(sigsuspend(&waitmask)!=-1) //将waitmask设置为当前进程的信号屏蔽字；
        err_sys("sigsuspend error");
    pr_mask("after return from sigsuspend:");
    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0) //将进程的信号屏蔽字重新设置为oldmask；
        err_sys("SIG_SETMASK error");
    
    pr_mask("program exit:");
    exit(0);
}
static void sig_int(int signo){
    pr_mask("\nin sig_int");
}

//10-23
#include"apue.h"

volatile sig_atomic_t quitflag;
static void sig_int(int signo){
    if(signo==SIGINT)
        printf("\ninterrupt\n");
    else if(signo==SIGQUIT)
        quitflag=1;
}
int main(void){
    sigset_t newmask,oldmask,zeromask;
    if(signal(SIGINT,sig_int)==SIG_ERR)
        err_sys("signal(SIGINT) error");
    if(signal(SIGQUIT,sig_int)==SIG_ERR)
        err_sys("signal(SIGQUIT) error");
    
    sigemptyset(&zeromask);
    sigemptyset(&newmask);
    sigaddset(&newmask,SIGQUIT);

    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0)
        err_sys("SIG_BLOCK error");
    while(quitflag==0)
        sigsuspend(&zeromask);
    quitflag=0;
    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)
        err_sys("SIG_SETMASK error");
    exit(0);
}

//-----------------------------------------------------
#include"apue.h"

//volatile指出变量是随时可能变化的，每次使用的时候必须从他的地址读入；
/*该关键字声明的变量可以被某些编译器未知的因素更改，比如操作系统，硬件或其他线程等；遇到这个关键字声明的变量，
编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问*/
volatile sig_atomic_t quitflag; //表示该变量是可能随时变化的；

//静态函数用于处理信号；
static void sig_int(int signo){
    if(signo==SIGINT)
        printf("\ninterrupt\n");
    else if(signo==SIGQUIT)
        quitflag=1;
}
int main(void){
    sigset_t newmask,oldmask,zeromask;
    //设置信号对应的处理程序：
    if(signal(SIGINT,sig_int)==SIG_ERR)
        err_sys("signal(SIGINT) error");
    if(signal(SIGQUIT,sig_int)==SIG_ERR)
        err_sys("signal(SIGQUIT) error");
    
    sigemptyset(&zeromask); //将zeromask清空，不屏蔽所有的信号；
    sigemptyset(&newmask); //将newmask清空，不屏蔽所有信号；
    sigaddset(&newmask,SIGQUIT); //屏蔽SIGQUIT信号；

    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0) //将newmask中屏蔽的信号添加到oldmask原本中；
        err_sys("SIG_BLOCK error");
    while(quitflag==0) //当处理完SIGQUIT信号后会使得quitflag值为1；只有当quitflag设置为0之后才会使用sigsuspend来将信号屏蔽字更新为zeromask；
        sigsuspend(&zeromask); //设置新的信号屏蔽字；
    quitflag=0;
    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0) //恢复原来的信号屏蔽字；
        err_sys("SIG_SETMASK error");
    exit(0);
}

//10-24
#include"apue.h"
static volatile sig_atomic_t sigflag;
static sigset_t newmask,oldmask,zeromask;

static void sig_usr(int signo){
    sigflag=1;
}

void TELL_WAIT(void){
    if(signal(SIGUSR1,sig_usr)==SIG_ERR)
        err_sys("signal(SIGUSR1) error");
    if(signal(SIGUSR2,sig_usr)==SIG_ERR)
        err_sys("signal(SIGUSR2) error");
    sigemptyset(&zeromask);
    sigemptyset(&newmask);
    sigaddset(&newmask,SIGUSR1);
    sigaddset(&newmask,SIGUSR2);

    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0)
        err_sys("SIG_BLOCK error");
}

void TELL_PARENT(pid_t pid){
    kill(pid,SIGUSR2);
}

void WAIT_PARENT(void){
    while(sigflag==0)
        sigsuspend(&zeromask);
    sigflag=0;

    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)
        err_sys("SIG_SETMASK error");
}

void TELL_CHILD(pid_t pid){
    kill(pid,SIGUSR1);
}

void WAIT_CHILD(void){
    while(sigflag==0)
        sigsuspend(&zeromask);
    sigflag=0;
    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)
        err_sys("SIG_SETMASK error");
}

//-----------------------------------------------------------

#include"apue.h"
static volatile sig_atomic_t sigflag;
static sigset_t newmask,oldmask,zeromask;

static void sig_usr(int signo){
    sigflag=1;
}

void TELL_WAIT(void){
    if(signal(SIGUSR1,sig_usr)==SIG_ERR)
        err_sys("signal(SIGUSR1) error");
    if(signal(SIGUSR2,sig_usr)==SIG_ERR)
        err_sys("signal(SIGUSR2) error");
    sigemptyset(&zeromask);
    sigemptyset(&newmask);
    sigaddset(&newmask,SIGUSR1);
    sigaddset(&newmask,SIGUSR2);

    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask)<0)
        err_sys("SIG_BLOCK error");
}

void TELL_PARENT(pid_t pid){
    kill(pid,SIGUSR2); //向pid进程发送SIGUSR2信号；
}

void WAIT_PARENT(void){
    while(sigflag==0)
        sigsuspend(&zeromask);
    sigflag=0;

    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)
        err_sys("SIG_SETMASK error");
}

void TELL_CHILD(pid_t pid){
    kill(pid,SIGUSR1); //向pid进程发送SIGUSR1信号；
}

void WAIT_CHILD(void){
    while(sigflag==0)
        sigsuspend(&zeromask);
    sigflag=0;
    if(sigprocmask(SIG_SETMASK,&oldmask,NULL)<0)
        err_sys("SIG_SETMASK error");
}


//10-25
#include<signal.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

void abort(void){
    sigset_t mask;
    struct sigaction action;

    sigaction(SIGABRT,NULL,&action);
    if(action.sa_handler==SIG_IGN){
        action.sa_handler=SIG_DFL;
        sigaction(SIGABRT,&action,NULL);
    }
    if(action.sa_handler==SIG_DFL)
        fflush(NULL);
    
    sigfillset(&mask);
    sigdelset(&mask,SIGABRT);
    sigprocmask(SIG_SETMASK,&mask,NULL);
    kill(getpid().SIGABRT);

    fflush(NULL);
    action.sa_handler=SIG_DFL;
    sigaction(SIGABRT,&action,NULL);
    sigprocmask(SIG_SETMASK,&mask,NULL);
    kill(getpid(),SIGABRT);
    exit(1);
}

//-------------------------------------------
#include<signal.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

void abort(void){
    sigset_t mask;
    struct sigaction action; //sigaction结构体；
    //sigaction函数第一个：要捕获的信号、第二个：接收到信号之后进行处理的结构体、第三个：接收到信号后保存对此信号原来的处理方式（备份）
    sigaction(SIGABRT,NULL,&action); 
    //action就是原来对abort信号的处理方式的备份：
    //sa_handler成员：对捕获信号进程处理的函数（概念上等同于单独使用signal函数）
    //sa_handler=SIGIGN（向内核表示忽略此信号），sa_handler=SIG_DFL(表示接到此信号的动作是系统默认动作)
    if(action.sa_handler==SIG_IGN){
        action.sa_handler=SIG_DFL;
        sigaction(SIGABRT,&action,NULL); //即将对abort信号的处理方式进行修改；
    }
    if(action.sa_handler==SIG_DFL)
        fflush(NULL);
    
    sigfillset(&mask); //将mask信号屏蔽字全部阻塞（即全部设置为1）
    sigdelset(&mask,SIGABRT); //解除对SIGABRT的阻塞；
    sigprocmask(SIG_SETMASK,&mask,NULL); //即将mask设置为当前进程的信号屏蔽字；也就是阻塞所有信号，除了SIGABRT信号；
    kill(getpid(),SIGABRT); //向当前进程发送SIGABRT信号；

    fflush(NULL);
    action.sa_handler=SIG_DFL;
    sigaction(SIGABRT,&action,NULL);
    sigprocmask(SIG_SETMASK,&mask,NULL);
    kill(getpid(),SIGABRT);
    exit(1);
}

//10-26
#include"apue.h"

static void sig_int(int signo){
    printf("caught SIGINT\n");
}
static void sig_chld(int signo){
    printf("Caught SIGCHLD\n");
}

int main(void){
    if(signal(SIGINT,sig_int)==SIG_ERR)
        err_sys("signal(SIGINT) error");
    if(signal(SIGCHLD,sig_chld)==SIG_ERR)
        err_sys("signal(SIGCHLD) error");
    if(system("/bin/ed")<0)
        err_sys("system() error");
    exit(0);
}


//10-28:
#include<sys/wait.h>
#include<errno.h>
#include<signal.h>
#include<unistd>

int system(const char *cmdstring){
    pid_t pid;
    int status;
    struct sigaction ignore,saveintr,savequit;
    sigset_t chldmask,savemask;

    if(cmdstring == NULL)
        return(1);
    ignore.sa_handler=SIG_IGN;
    sigemptyset(&ignore.sa_mask);
    ignore.sa_flags=0;
    if(sigaction(SIGINT,&ignore,&saveintr)<0)
        return(-1);
    if(sigaction(SIGQUIT,&ignore,&savequit)<0)
        return (-1);
    sigemptyset(&chldmask);
    sigaddset(&chldmask,SIGCHLD);
    if(sigprocmask(SIG_BLOCK,&chldmask,&savemask)<0)
        return(-1);

    if((pid=fork())<0){
        status=-1;
    }else if(pid==0){
        sigaction(SIGINT,&saveintr,NULL);
        sigaction(SIGQUIT,&savequit,NULL);
        sigprocmask(SIG_SETMASK,&savemask,NULL);

        execl("/bin/sh","sh","-c",cmdstring,(char *)0);
        _exit(127);
    }else{
        while(waitpid(pid,&status,0)<0)
            if(errno!=EINTR){
                status=-1;
                break;
            }
    }

    if(sigaction(SIGINT,&saveintr,NULL)<0)
        return(-1);
    if(sigaction(SIGQUIT,&savequit,NULL)<0)
        return(-1);
    if(sigprocmask(SIG_SETMASK,&savemask,NULL)<0)
        return(-1);
    
    return status;
}

//-----------------------------------------------------------
//10-28
//主要就是对system函数的实现，其会fork一个子进程用于处理输入进来的命令字符串，在子进程中处理信号的方式可能和原来的不一样；
//所以回到父进程之后再将这些恢复成默认情况；
#include<sys/wait.h>
#include<errno.h>
#include<signal.h>
#include<unistd>

int system(const char *cmdstring){
    pid_t pid; //用于记录进程号；
    int status; //状态；
    struct sigaction ignore,saveintr,savequit; //结构体；
    sigset_t chldmask,savemask; //信号屏蔽字的定义；

    if(cmdstring == NULL)
        return(1);
    ignore.sa_handler=SIG_IGN; //设置为SIG——IGN“忽略”的行为；
    sigemptyset(&ignore.sa_mask); //将ignore的信号屏蔽字全部清空；
    ignore.sa_flags=0;

    //sigaction函数第一个：要捕获的信号、第二个：接收到信号之后进行处理的结构体、第三个：接收到信号后保存对此信号原来的处理方式（备份）
    if(sigaction(SIGINT,&ignore,&saveintr)<0)  //对接收到的信号原来的处理方式记录在saveintr中，并且进行ignore结构体中定义的进行处理；
        return(-1);
    if(sigaction(SIGQUIT,&ignore,&savequit)<0)
        return (-1);
    sigemptyset(&chldmask);
    sigaddset(&chldmask,SIGCHLD); //设置SIGCHLD信号的阻塞；
    if(sigprocmask(SIG_BLOCK,&chldmask,&savemask)<0) //将SIGCHLD信号阻塞添加到原来的阻塞信号中（更新信号屏蔽字）
        return(-1);

    if((pid=fork())<0){ //只有fork()>=0时表示该函数正确调用；
        status=-1;//出错进行状态设置为-1；
    }else if(pid==0){ //pid=fork()=0表示是子进程；
        sigaction(SIGINT,&saveintr,NULL); //要捕获SIGINT信号，并且使用saveintr进行处理；（使用该信号原本的方式进行处理；）
        sigaction(SIGQUIT,&savequit,NULL); //要捕获的SIGQUIT信号，使用savequit进行处理；原先的方式进行处理；
        sigprocmask(SIG_SETMASK,&savemask,NULL); //将信号屏蔽字重新设置为savemask指向的（就是进程原本的信号屏蔽字）；

        execl("/bin/sh","sh","-c",cmdstring,(char *)0); //运行程序；
        _exit(127); //退出子进程；
    }else{ //这里表示是父进程；
        while(waitpid(pid,&status,0)<0) //等待子进程返回；
            if(errno!=EINTR){
                status=-1;
                break;
            }
    }

    //下面将对捕获的信号进行处理的方式和信号屏蔽字都恢复成默认的情况；
    if(sigaction(SIGINT,&saveintr,NULL)<0)
        return(-1);
    if(sigaction(SIGQUIT,&savequit,NULL)<0)
        return(-1);
    if(sigprocmask(SIG_SETMASK,&savemask,NULL)<0)
        return(-1);
    
    return status;
}



//11-2
#include"apue.h"
#include<pthread.h>
pthread_t ntid;

void printids(const char *s){
    pid_t pid;
    pthread_t tid;

    pid=getpid();
    tid=pthread_self();
    printf("%s pid %lu tid %lu (0x%1lx)\n",s,(unsigned long)pid,(unsigned long)tid,(unsigned long)tid);
}

void thr_fn(void *arg){
    printids("new thread: ");
    return((void*)0);
}

int main(void){
    int err;
    err=pthread_create(&ntid,NULL,thr_fn,NULL);
    if(err!=0)
        err_exit(err,"can't create thread");
    printids("main thread:");
    sleep(0);
    exit(0);
}

//11-3
#include"apue.h"
#include<pthread.h>

void *thr_fn1(void *arg){
    printf("thread 1 returning\n");
    return((void*)1);
}

void *thr_fn2(void *arg){
    printf("thread 2 exiting\n");
    pthread_exit((void*)2);
}

int main(void){
    int err;
    pthread_t tid1,tid2;
    void *tret;
    err=pthread_create(&tid1,NULL,thr_fn1,NULL);
    if(err!=0)
        err_exit(err,"can't create thread1");
    err=pthread_create(&tid2,NULL,thr_fn2,NULL);

    if(err!=0)
        err_exit(err,"can't create thread 2");
    err=pthread_join(tid1,&tret);
    if(err!=0)
        err_exit(err,"can't join with thread 1");
    printf("thread 1 exit code %ld\n",(long)tret);
    err=pthread_join(tid2,&tret);

    if(err!=0)
        err_exit(err,"can't join with thread 2");
    printf("thread 2 exit code %ld\n",(long)tret);
    exit(0);
}

//----------------------------------------------------
#include"apue.h"
#include<pthread.h>

void *thr_fn1(void *arg){
    printf("thread 1 returning\n");
    return((void*)1);
}

void *thr_fn2(void *arg){
    printf("thread 2 exiting\n");
    pthread_exit((void*)2);
}

int main(void){
    int err;
    pthread_t tid1,tid2;  //表示线程ID；
    void *tret;
    //新创建的线程ID会存储在tid1指向的内存单元；第二个mull表示是使用默认的线程属性，
    //新创建的线程从thr_fn1地址函数开始；并且第四个参数作为该函数的参数传入；
    err=pthread_create(&tid1,NULL,thr_fn1,NULL);
    if(err!=0) //不等于0表示创建线程失败；
        err_exit(err,"can't create thread1");
    err=pthread_create(&tid2,NULL,thr_fn2,NULL);
    if(err!=0)
        err_exit(err,"can't create thread 2");
    //上面创建了两个线程分别是tid1和tid2；
    //pthread_join即是子线程合入主线程，主线程阻塞等待子线程结束，然后回收子进程资源；
    //tid1是线程ID，tret是用户指定的指针，用来存储等待线程的返回值；
    err=pthread_join(tid1,&tret); //等待tid1运行结束回收；
    if(err!=0)
        err_exit(err,"can't join with thread 1");
    printf("thread 1 exit code %ld\n",(long)tret);
    err=pthread_join(tid2,&tret); //等待tid2运行结束回收；
    if(err!=0)
        err_exit(err,"can't join with thread 2");
    printf("thread 2 exit code %ld\n",(long)tret);
    exit(0);
}



//11-4:用自动变量（分配在栈上）作为pthread_exit的参数时出现的问题；
#include "apue.h"
#include<pthread.h>

struct foo{
    int a,b,c,d;
};

void printfoo(const char *s,const struct foo *fp){
    printf("%s",s);
    printf(" structure at 0x%lx\n",(unsigned long)fp);
    printf(" foo.a=%d\n",fp->a);
    printf(" foo.c=%d\n",fp->c);
    printf(" foo.d=%d\n",fp->d);
}

void *thr_fn1(void *arg){
    struct foo foo={1,2,3,4};

    printfoo("thread 1:\n",&foo);
    pthread_exit((void *)&foo);
}

void *thr_fn2(void *arg){
    printf("thread 2: ID is %lu\n",(unsigned long)pthread_self());
    pthread_exit((void *)0);
}

int main(void){
    int err;
    pthread_t tid1,tid2;
    struct foo *fp;

    err=pthread_create(&tid1,NULL,thr_fn1,NULL);
    if(err!=0)
        err_exit(err,"can't create thread 1");
    err=pthread_join(tid1,(void *)&fp);
    if(err!=0)
        err_exit(err,"can't join with thread 1");
    sleep(1);
    printf("parent starting second thread\n");
    err=pthread_create(&tid2,NULL,thr_fn2,NULL);
    if(err!=0)
        err_exit(err,"can't create thread 2");
    sleep(1);
    printfoo("parent:\n",fp);
    exit(0);
}

//----------------------------------------------#include "apue.h"
#include"apue.h"
#include<pthread.h>

//一个结构体，其中可以存放几个变量；
struct foo{
    int a,b,c,d;
};

//打印：
void printfoo(const char *s,const struct foo *fp){
    printf("%s",s);
    printf(" structure at 0x%lx\n",(unsigned long)fp);
    printf(" foo.a=%d\n",fp->a);
    printf(" foo.c=%d\n",fp->c);
    printf(" foo.d=%d\n",fp->d);
}

void *thr_fn1(void *arg){
    struct foo foo={1,2,3,4};

    printfoo("thread 1:\n",&foo);
    pthread_exit((void *)&foo);
}

void *thr_fn2(void *arg){
    printf("thread 2: ID is %lu\n",(unsigned long)pthread_self());
    pthread_exit((void *)0);
}

int main(void){
    int err;
    pthread_t tid1,tid2; //定义线程号；
    struct foo *fp; //fp是指向指定结构体的指针；

    err=pthread_create(&tid1,NULL,thr_fn1,NULL); //这里创建一个线程，线程ID放入tid1中；采用默认的配置；线程运行的起始地址是thr_fn1函数位置；没有传入该函数的参数；
    if(err!=0) //创建失败；
        err_exit(err,"can't create thread 1");

    err=pthread_join(tid1,(void *)&fp); //使用pthread_join函数阻塞等待tid1线程结束，将其返回状态存入fp指向的内存中；
    if(err!=0)
        err_exit(err,"can't join with thread 1");
    sleep(1);
    printf("parent starting second thread\n");
    err=pthread_create(&tid2,NULL,thr_fn2,NULL); //再创建一个新线程；
    if(err!=0)
        err_exit(err,"can't create thread 2");
    sleep(1);
    printfoo("parent:\n",fp);
    exit(0);
}

//11-5:如何使用线程清理处理程序
#include"apue.h"
#include<pthread.h>

void cleanup(void *arg){
    printf("cleanup: %s\n",(char *)arg);
}

void * thr_fn1(void *arg){
    printf("thread 1 start\n");
    pthread_cleanup_push(cleanup,"thread 1 first handler");
    pthread_cleanup_push(cleanup,"thread 1 second handler");
    printf("thread 1 push complete\n");
    if(arg)
        return ((void *)1);
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    return ((void *)1);
}

void * thr_fn2(void *arg){
    printf("thread 2 start\n");
    pthread_cleanup_push(cleanup,"thread 2 first handler");
    pthread_cleanup_push(cleanup,"thread 2 first handler");
    printf("thread 2 push complete\n");
    if(arg)
        pthread_exit((void *)2);
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    pthread_exit((void *)2);
}

int main(void){
    int err;
    pthread_t tid1,tid2;
    void *tret;
    err=pthread_create(&tid1,NULL,thr_fn1,(void *)1);
    if(err!=0)err_exit(err,"can't create thread 1");
    err=pthread_create(&tid2,NULL,thr_fn2,(void *)1);
    if(err!=0)err_exit(err,"can't create thread 2");
    err=pthread_join(tid1,&tret);
    if(err!=0)err_exit(err,"can't join with thread 1");
    printf("thread 1 exit code %ld\n",(long)tret);
    err=pthread_join(tid2,&tret);
    if(err!=0)err_exit(err,"can't join with thread 2");
    printf("thread 2 exit code %ld\n",(long)tret);

    exit(0);
}

//---------------------------------------------------
#include"apue.h"
#include<pthread.h>

 //自定义的线程清理处理函数；
void cleanup(void *arg){
    printf("cleanup: %s\n",(char *)arg);
}

void * thr_fn1(void *arg){
    printf("thread 1 start\n");
    //将线程清理程序进行注册；
    pthread_cleanup_push(cleanup,"thread 1 first handler");
    pthread_cleanup_push(cleanup,"thread 1 second handler");
    printf("thread 1 push complete\n");
    if(arg)
        return ((void *)1);
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    return ((void *)1);
}

void * thr_fn2(void *arg){
    printf("thread 2 start\n");
    pthread_cleanup_push(cleanup,"thread 2 first handler");
    pthread_cleanup_push(cleanup,"thread 2 second handler");
    printf("thread 2 push complete\n");
    if(arg)
        pthread_exit((void *)2);
    pthread_cleanup_pop(0);
    pthread_cleanup_pop(0);
    pthread_exit((void *)2);
}

int main(void){
    int err;
    pthread_t tid1,tid2;
    void *tret;
    //下面创建两个线程；
    err=pthread_create(&tid1,NULL,thr_fn1,(void *)1);
    if(err!=0)err_exit(err,"can't create thread 1");
    err=pthread_create(&tid2,NULL,thr_fn2,(void *)1);
    if(err!=0)err_exit(err,"can't create thread 2");
    //下面使用pthread_join等待线程的终止；
    err=pthread_join(tid1,&tret);
    if(err!=0)err_exit(err,"can't join with thread 1");
    printf("thread 1 exit code %ld\n",(long)tret);
    err=pthread_join(tid2,&tret);
    if(err!=0)err_exit(err,"can't join with thread 2");
    printf("thread 2 exit code %ld\n",(long)tret);

    exit(0);
}


//11-10
#include<stdlib.h>
#include<pthread.h>

struct foo{
    int f_count;
    pthread_mutex_t f_lock;
    int f_id;
};

struct foo *foo_alloc(int id){
    struct foo *fp;
    if((fp=malloc(sizeof(struct foo)))!=NULL){
        fp->f_count=1;
        fp->f_id=id;
        if(pthread_mutex_init(&fp->f_lock,NULL)!=0){
            free(fp);
            return(NULL);
        }
    }
    return (fp);
}

void foo_hold(struct foo *fp){
    pthread_mutex_lock(&fp->f_lock);
    fp->f_count++;
    pthread_mutex_unlock(&fp->lock);
}

void foo_rele(struct foo *fp){
    pthread_mutex_lock(&fp->f_lock);
    if(--fp->f_count ==0){
        pthread_mutex_unlock(&fp->f_lock);
        pthread_mutex_destroy(&fp->f_lock);
        free(fp);
    }else{
        pthread_mutex_unlock(&fp->f_lock);
    }
}
//-----------------------------------------------

//11-10
#include<stdlib.h>
#include<pthread.h>

//foo结构体：
struct foo{
    int f_count; //当前引用的数量；
    pthread_mutex_t f_lock; //表示互斥量；
    int f_id;
};

//主要用于对foo结构体进行分配空间并且进行初始化：
struct foo *foo_alloc(int id){
    struct foo *fp; 
    if((fp=malloc(sizeof(struct foo)))!=NULL){
        fp->f_count=1; 
        fp->f_id=id;
        //上面首先创建一个用于记录互斥量的结构体，对其中的各个元素进行初始化操作；
        if(pthread_mutex_init(&fp->f_lock,NULL)!=0){ //pthread_mutex_init该函数用于对互斥量的初始化；使用fp进行初始化；
            free(fp);
            return(NULL);
        }
    }
    return (fp);
}

void foo_hold(struct foo *fp){
    pthread_mutex_lock(&fp->f_lock); //对该互斥量进行加锁；
    fp->f_count++; //表示引用该的对象+1；
    pthread_mutex_unlock(&fp->lock); //对互斥量解锁；
}

void foo_rele(struct foo *fp){
    pthread_mutex_lock(&fp->f_lock); //互斥量加锁；
    if(--fp->f_count ==0){
        pthread_mutex_unlock(&fp->f_lock);
        pthread_mutex_destroy(&fp->f_lock);
        free(fp);
    }else{
        pthread_mutex_unlock(&fp->f_lock);
    }
}

//11-11
#include<pthread.h>

#define NHASH 29
#define HASH(id) ((unsigned long)id)%NHASH

struct foo *fh[NHASH];
pthread_mutex_t hashlock=PTHREAD_MUTEX_INITIALIZER;

struct foo{
    int f_count;
    pthread_mutex_t f_lock;
    int f_id;
    struct foo *f_next;
};

struct foo *foo_alloc(int id){
    struct foo *fp;
    int idx;
    if((fp=malloc(sizeof(struct foo)))!=NULL){
        fp->f_count=1;
        fp->f_id=id;
        if(pthread_mutex_init(&fp->f_lock,NULL)!=0){
            free(fp);
            return(NULL);
        }
        idx=HASH(id);
        pthread_mutex_lock(&hashlock);
        fp->f_next=fh(idx);
        fh[idx]=fp;
        pthread_mutex_lock(&fp->f_lock);
        pthread_mutex_unlock(&hashlock);

        pthread_mutex_unlock(&fp->f_lock);
    }
    return(fp);
}

void foo_hold(struct foo *fp){
    pthread_mutex_lock(&fp->f_lock);
    fp->f_count++;
    pthread_mutex_unlock(&fp->f_lock);
}
struct foo * foo_find(int id){
    struct foo *fp;
    pthread_mutex_lock(&hashlock);
    for(fp->fh[HASH(id)];fp!=NULL;fp=fp->f_next){
        if(fp->f_id==id){
            foo_hold(fp);
            break;
        }
    }
    pthread_mutex_unlock(&hashlock);
    return(fp);
}

void foo_rele(struct foo *fp){
    struct foo *tfp;
    int idx;
    pthread_mutex_lock(&fp->f_lock);
    if(fp->f_count==1){
        pthread_mutex_unlock(&fp->f_lock);
        pthread_mutex_lock(&hashlock);
        pthread_mutex_lock(&fp->f_lock);
        if(fp->f_count!=1){
            fp->f_count--;
            pthread_mutex_unlock(&fp->f_lock);
            pthread_mutex_unlock(&&hashlock);
            return;
        }
        idx=HASH(fp->f_id);
        tfp=fh[idx];
        if(tfp==fp){
            fh[idx]=fp->f_next;
        }else{
            while(tfp->f_next!=fp)
                tfp=tfp->f_next;
            tfp->f_next=fp->f_next;
        }
        pthread_mutex_unlock(&hashlock);
        pthread_mutex_unlock(&fp->f_next);
        pthread_mutex_destroy(&fp->f_lock);
        free(fp);
    }else{
        fp->f_count--;
        pthread_mutex_unlock(&fp->f_lock);
    }
}

//---------------------------------------------------------------

//11-11
#include<pthread.h>

#define NHASH 29 //固定一个值防止后续变化；
#define HASH(id) ((unsigned long)id)%NHASH //定义一个取模；

struct foo *fh[NHASH]; //这里创建一个数组，其中有NHASH个元素，每一个元素是指向foo结构体的指针；
pthread_mutex_t hashlock=PTHREAD_MUTEX_INITIALIZER;//锁可以被动态或静态创建，这种是静态初始化锁；

//这里是自己定义的一个结构体：
struct foo{
    int f_count;  //当前引用该结构体的数量；
    pthread_mutex_t f_lock; //锁；
    int f_id;
    struct foo *f_next;
};

//对foo结构体进行分配空间；
struct foo *foo_alloc(int id){
    struct foo *fp;
    int idx;
    if((fp=malloc(sizeof(struct foo)))!=NULL){ //malloc函数分配成功返回指向其分配的内存地址；
        fp->f_count=1; //创建一个新的对该结构体的引用，引用计数+1
        fp->f_id=id; //id号；
        //上面首先创建一个用于记录互斥量的结构体，对其中的各个元素进行初始化操作；
        //pthread_mutex_init函数的返回值不等于0表示初始化锁fp->lock失败；
        if(pthread_mutex_init(&fp->f_lock,NULL)!=0){ //使用这个fp来对互斥量进行初始化；动态创建一个互斥锁；
            free(fp);//释放fp；
            return(NULL);
        }
        //如果初始化锁成功之后：
        idx=HASH(id); 
        pthread_mutex_lock(&hashlock);//对这个数组进行加锁；
        fp->f_next=fh(idx); //将记录互斥量的结构体放入数组中，并且fp指向这个结构体；
        fh[idx]=fp;
        pthread_mutex_lock(&fp->f_lock); //对该结构体中对应的互斥量进行加锁；
        pthread_mutex_unlock(&hashlock); //解锁；

        pthread_mutex_unlock(&fp->f_lock); //解锁；
    }
    return(fp); //返回一个指向记录互斥量结构体的指针；
}

//该函数用于记录对互斥量的hold；也就是多一个hold该互斥量的，就把记录该互斥量的结构体中的count数目+1；
void foo_hold(struct foo *fp){
    pthread_mutex_lock(&fp->f_lock); //先加锁
    fp->f_count++; //修改对该互斥量的引用数目，+1；
    pthread_mutex_unlock(&fp->f_lock); //解锁；
}
//找到id的互斥量结构体；
struct foo * foo_find(int id){    
    struct foo *fp;
    pthread_mutex_lock(&hashlock); //对数组进行加锁；
    for(fp=fh[HASH(id)];fp!=NULL;fp=fp->f_next){
        if(fp->f_id==id){
            foo_hold(fp);
            break;
        }
    }
    pthread_mutex_unlock(&hashlock);
    return(fp);
}
//对该结构体进行释放：
void foo_rele(struct foo *fp){
    struct foo *tfp;
    int idx;
    pthread_mutex_lock(&fp->f_lock); //锁住，防止有新的增加减少的操作；
    if(fp->f_count==1){ //表示只有一个引用了
        pthread_mutex_unlock(&fp->f_lock);  //解开；
        pthread_mutex_lock(&hashlock); //锁住散列表；
        pthread_mutex_lock(&fp->f_lock); //锁住该结构体；
        if(fp->f_count!=1){ //表示还有多于1个的引用；只要减少count就可以；
            fp->f_count--; 
            pthread_mutex_unlock(&fp->f_lock);
            pthread_mutex_unlock(&&hashlock);
            return;
        }
        //如果只有1个了；
        idx=HASH(fp->f_id); //获取其在散列表中的位置索引；
        tfp=fh[idx];//获取该位置的结构体；
        if(tfp==fp){
            fh[idx]=fp->f_next; //删除这个散列表中的元素
        }else{
            while(tfp->f_next!=fp) //一直找；
                tfp=tfp->f_next;
            tfp->f_next=fp->f_next;
        }
        pthread_mutex_unlock(&hashlock);
        pthread_mutex_unlock(&fp->f_next);
        pthread_mutex_destroy(&fp->f_lock);
        free(fp);
    }else{
        fp->f_count--;
        pthread_mutex_unlock(&fp->f_lock);
    }
}


//11-13
#include"apue.h"
#include<pthread.h>

int main(void){
    int err;
    struct timespec tout;
    struct tm *tmp;
    char buf[64];
}

